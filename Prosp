#!/usr/bin/python2 -i

backgrounds=[]

try:
  import readline
except ImportError:
  ewrite("Module readline not available.")
else:
  import rlcompleter
  readline.parse_and_bind("tab: complete")

import Ariel
import ArCommands

import sys
import time       #for the 'sleep' function
import types
import improc
from improc import reduce
import autorun
from autorun import auto
import planet
from planet import *
import teljoy
from teljoy import *
import weather

backgrounds.append(teljoy._background)
backgrounds.append(weather._background)

from globals import *
import utils
from utils import *
import ephemint
from ephemint import *


def help(func):
  "Usage: help(function) to find out information about that function"
  if type(func)==type(''):
    print "     "+getattr(__builtins__.globals()[func],'func_doc')
  else:
    print "     "+func.func_doc


def _background():
  "Call each of the registered background functions every 5 seconds"
  while 1:

    if status.MonitorActive:
      if status.weather.clear and isdark() and (not teljoy.Active.isSet()):
        teljoy.unpause()
      if (not status.weather.clear) and teljoy.Active.isSet():
        teljoy.pause()
      if (not ephemint.isdark()) and teljoy.Active.isSet():
        print "End of the night, pausing forever. To resume,"
        print "type 'status.MonitorActive=0', then 'teljoy.unpause()'"
        teljoy.pause()

    status.isdark=ephemint.isdark()

    for f in backgrounds:
      f()
    time.sleep(5)


class Prompt:
  """Class to assign to sys.ps1, str() method is called every time a prompt is
     printed. Used to make sure that the background thread is still alive.
  """
  def __str__(self):
    global BGThread
    if GotAriel:
      if not BGThread.isAlive():
        BGThread=threading.Thread(group=None,
                                  target=_background)
        BGThread.setDaemon(1)
        BGThread.start()
    return ">>>"



def monitor(arg=None, close=None, open=None, delay=None):
  """Usage: monitor('ON') or monitor('OFF')
     Turns weather monitoring on or off. Uses default cloud parameters, or the
     values previously set if the command has been used previously in a session.
     or:
     monitor('ON', close=6000, open=5900, delay=1800)
     If the 'close', 'open' and 'delay' parameters are given, uses these for
     CloudCloseLevel, CloudOpenLevel and WeatherOpenDelay respectively.

     These parameters are:
     CloudCloseLevel:  When the clouds reach this level, the dome closes and
                       the system pauses.
     CloudOpenLevel:   If the system is paused, the cloud level needs to be
                       below this (and not raining) for it to be 'clear'.
     WeatherOpenDelay: If the system is paused, the weather needs to be 'clear'
                       (see above) for this many seconds before the system is
                       un-paused.
    To change the parameters, just use another monitor('ON',....) command with
    different parameter values.
    Note that even if the command aborts when you try and turn monitoring on,
    any parameters given are still parsed, and will be used later unless
    overriden! 
    Use monitor() with no arguments to get the current weather status.
  """
  if type(arg)==types.StringType:
    arg=string.upper(arg)
  if arg=='OFF':
    print "Monitoring OFF."
    status.MonitorActive=0
    if not teljoy.Active.isSet():
      teljoy.unpause()
  elif arg=='ON':
    if type(close)==types.FloatType or type(close)==types.IntType:
      status.weather.CloudCloseLevel=int(close)
    if type(open)==types.FloatType or type(open)==types.IntType:
      status.weather.CloudOpenLevel=int(open)
    if type(delay)==types.FloatType or type(delay)==types.IntType:
      status.weather.WeatherOpenDelay=int(delay)
    if not isdark():
      print "It's not dark yet, monitoring mode would pause immediately."
      print "Monitor mode aborted."
      return 0
    if status.weather.cloud > status.weather.CloudCloseLevel:
      print "It's too cloudy, monitoring mode would pause immediately."
      print "Monitor mode aborted."
      return 0
    status.weather.OKforsec=86400
    status.MonitorActive=1
    print "Monitoring ON, 'clear' delay timer reset to force immediate unpausing\n"
    status.weather.display()
  else:
    print "type 'help(monitor)' for usage information.\nStatus:"
    status.weather.display()
    
    


sys.ps1=Prompt() 

status=Ariel.ArielStatus()  #Define a status variable using the new class
status.TJ=teljoy.status
status.TJ.updated=status.updated  #Flag main status updated when TJ changes
status.weather=weather.status
status.MonitorActive=0
status.isdark=1


Ariel.status=status        #Make it the interface libraries status global
ArCommands.status=status   #And the Ariel commands module
autorun.status=status     #And the AutoRun libraries status global too
utils.status=status       #And the utility commands module
sys.path=sys.path+['.']   #Allow user-written modules in current dir to load


try:
  Ariel.init()        #Call the init() function in the library to open
                      #communications with the camera
except Ariel.ArielError:
  GotAriel=0
  ewrite("Ariel init failed.")
  ewrite("Another program is using the Ariel++ interface to control the AP7.")
  print "Continuing without access to the AP7 hardware - to connect to the "
  print "camera, quit this program, quit from or kill the other instance of"
  print "Prosp, and restart. Use 'ps -a' to find other instances of the"
  print "program."
else:
  GotAriel=1
  swrite("Ariel init succeeded, contact with AP7 established.")
  from ArCommands import *


if GotAriel:
  BGThread=threading.Thread(group=None,
                     target=_background)
  BGThread.setDaemon(1)
  BGThread.start()

